#!/usr/bin/env ruby

require 'rubygems'
require 'optparse'

$stdout.sync = true

class Push
  DEFAULT_OPTIONS = {
    heroku: false,
    migrate: false,
    commit: true,
    pull: false,
    update: false,
    message: nil
  }

  def echo str, options = {}
    str = "| #{ str } |"
    dashes = str.length.times.map { '-' }.join
    message = "#{ dashes }\n#{ str }\n#{ dashes }"
    "echo \"#{ message }\""
  end

  def options
    @options ||= lambda { |options|
      @parser = OptionParser.new do |opts|
        opts.banner = "Usage: deploy [-hm] <COMMIT-MESSAGE>"
        opts.on '-h', '--heroku', 'Deploys code to heroku' do
          options[:heroku] = true
        end
        opts.on '-m', '--migrate', 'Migrates after deploy' do |msg|
          options[:migrate] = true
        end
        opts.on '-c', '--no-commit', 'Don\'t try to commit, just push' do
          options[:commit] = false
        end
        opts.on '-p', '--pull', 'Pull origin master before push. Exists if conflict exist' do
          options[:pull] = true
        end
        opts.on '--update', 'Updates the deploy script from remote git repo' do
          options[:update] = true
        end
        opts.on '--help', "Shows this help message" do
          abort parser.help
        end
      end

      @parser.parse!

      options[:message] = ARGV.shift

      # Return options
      options
    }.call(DEFAULT_OPTIONS)
  end

  def message
    abort @parser.help if options[:commit] && !options[:message]

    push = ""

    if options[:commit]
      push += <<-COMMAND
        git add . && \
        #{ echo "Committing : '#{ options[:message] }' ..." } && \
        git commit -a -m "#{ options[:message] }" &&
      COMMAND
    end

    if options[:pull]
      push += <<-COMMAND
        #{ echo "Pulling master ..." } && \
        git remote show origin | grep "local out of date" &>/dev/null; \
        if [ $? -ne 0 ]; then
          echo "Nothing to pull";
        else
          git pull origin master
          git status | grep "working directory clean" &>/dev/null
          if [ $? -ne 0 ]; then
            echo "Need to merge, exiting ..."
            exit
          fi
        fi
      COMMAND
    end

    push += <<-COMMAND
      #{ echo "Pushing to master ..."} && \
      git push origin master &&
    COMMAND

    if options[:heroku]
      push += <<-COMMAND
        #{ echo "Deploying to Heroku master ..." } && \
        git push heroku master &&
      COMMAND

      # Migrations are only run when deployed to heroku
      if options[:migrate]
        push += <<-COMMAND
          #{ echo "Running app's migrations" } && \
          heroku run "rake db:migrate" &&
        COMMAND
      end
    end

    push += echo("Deployed !")
  end

  def update!
    command = <<-COMMAND
      #{ echo "Updating deploy ..." } && \
      git clone git@github.com:vala/deploy /tmp/deploy && \
      echo "\nPassword will be required to move executable to /usr/bin/deploy" && \
      sudo mv /tmp/deploy/deploy /usr/bin/deploy && \
      rm -rf /tmp/deploy && \
      #{ echo "Updated !" }
    COMMAND

    IO.popen(command) do |f|
      puts f.gets until f.eof?
    end
  end

  def run
    if options[:update]
      update!
    else
      # Store start time
      start_time = Time.now
      # Run and synchronously log stdout
      IO.popen(message) do |f|
        puts f.gets until f.eof?
      end
      # Store deploy duration
      time = Time.now - start_time
      puts "Time : #{ time } seconds"
    end
  end
end

# Instantiate and run
Push.new.run
